import Lean
import Dap.Syntax

open Lean
open Lean.Elab
open Lean.Elab.Term

namespace Dap

declare_syntax_cat dap_rhs
declare_syntax_cat dap_stmt

syntax num : dap_rhs
syntax "add" ident ident : dap_rhs
syntax "sub" ident ident : dap_rhs
syntax "mul" ident ident : dap_rhs
syntax "div" ident ident : dap_rhs

syntax "let " ident " := " dap_rhs : dap_stmt

/--
Program literal syntax for the toy language.

Example:
```
def p : Dap.Program := dap%[
  let x := 1,
  let y := 2,
  let z := add x y
]
```
-/
syntax (name := dapProgramTerm) "dap%[" dap_stmt,* "]" : term

/--
Like `dap%[...]`, but also keeps source span metadata for each statement.
-/
syntax (name := dapProgramInfoTerm) "dapInfo%[" dap_stmt,* "]" : term

/-- Convenience command macro to define a `Dap.Program` from DSL syntax. -/
syntax (name := dapProgramDefCmd) "dap_program " ident " := " term : command

/-- Convenience command macro to define a `Dap.ProgramInfo` from DSL syntax. -/
syntax (name := dapProgramInfoDefCmd) "dap_program_info " ident " := " term : command

macro_rules
  | `(dap_program $name:ident := $program:term) =>
      `(def $name : Dap.Program := $program)
  | `(dap_program_info $name:ident := $programInfo:term) =>
      `(def $name : Dap.ProgramInfo := $programInfo)

private structure ProgramSyntaxInfo where
  located : Array LocatedStmt
  deriving TypeName

/-- Convert the custom infotree payload generated by `dap%[...]` and `dapInfo%[...]`. -/
def getProgramSyntaxInfo? : Elab.Info → Option (Array LocatedStmt)
  | .ofCustomInfo custom =>
    (custom.value.get? ProgramSyntaxInfo).map (·.located)
  | _ =>
    none

private def varOfIdent (id : TSyntax `ident) : Var :=
  id.getId.toString

private def parseNatLiteral (numStx : TSyntax `num) : TermElabM Nat :=
  match numStx.raw.isNatLit? with
  | some value =>
    pure value
  | none =>
    throwErrorAt numStx "expected a natural number literal"

private def parseStmt : Syntax → TermElabM Stmt
  | `(dap_stmt| let $dest:ident := $n:num) => do
    let value := Int.ofNat (← parseNatLiteral n)
    pure (Stmt.letConst (varOfIdent dest) value)
  | `(dap_stmt| let $dest:ident := add $lhs:ident $rhs:ident) =>
    pure (Stmt.letBin (varOfIdent dest) .add (varOfIdent lhs) (varOfIdent rhs))
  | `(dap_stmt| let $dest:ident := sub $lhs:ident $rhs:ident) =>
    pure (Stmt.letBin (varOfIdent dest) .sub (varOfIdent lhs) (varOfIdent rhs))
  | `(dap_stmt| let $dest:ident := mul $lhs:ident $rhs:ident) =>
    pure (Stmt.letBin (varOfIdent dest) .mul (varOfIdent lhs) (varOfIdent rhs))
  | `(dap_stmt| let $dest:ident := div $lhs:ident $rhs:ident) =>
    pure (Stmt.letBin (varOfIdent dest) .div (varOfIdent lhs) (varOfIdent rhs))
  | stx =>
    throwErrorAt stx "invalid toy-language statement; expected `let v := N` or `let v := op v1 v2`"

private def spanOfSyntax (fileMap : FileMap) (stx : Syntax) : StmtSpan :=
  match stx.getPos?, stx.getTailPos? with
  | some startPos, some endPos =>
    let start := fileMap.toPosition startPos
    let ending := fileMap.toPosition endPos
    {
      startLine := start.line
      startColumn := start.column
      endLine := ending.line
      endColumn := ending.column
    }
  | _, _ =>
    default

private def parseLocatedStmt (fileMap : FileMap) (stmtStx : Syntax) : TermElabM LocatedStmt := do
  let stmt ← parseStmt stmtStx
  let span := spanOfSyntax fileMap stmtStx
  pure { stmt, span }

private def pushProgramInfoNode (stx : Syntax) (located : Array LocatedStmt) : TermElabM Unit := do
  pushInfoLeaf <| .ofCustomInfo
    { stx
      value := Dynamic.mk ({ located } : ProgramSyntaxInfo) }

private def elabLocatedStmtsFromProgramTerm (stx : Syntax) : TermElabM (Array LocatedStmt) := do
  let fileMap ← getFileMap
  let stmtStxs := stx[1].getSepArgs
  stmtStxs.mapM (parseLocatedStmt fileMap)

@[term_elab dapProgramTerm]
def elabDapProgram : TermElab := fun stx _expectedType? => withRef stx do
  let located ← elabLocatedStmtsFromProgramTerm stx
  let program : Program := located.map (·.stmt)
  pushProgramInfoNode stx located
  let expr := toExpr program
  addTermInfo' stx expr (isDisplayableTerm := true)
  pure expr

@[term_elab dapProgramInfoTerm]
def elabDapProgramInfo : TermElab := fun stx _expectedType? => withRef stx do
  let located ← elabLocatedStmtsFromProgramTerm stx
  let programInfo : ProgramInfo := { program := located.map (·.stmt), located }
  pushProgramInfoNode stx located
  let expr := toExpr programInfo
  addTermInfo' stx expr (isDisplayableTerm := true)
  pure expr

end Dap
