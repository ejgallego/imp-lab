/-
Copyright (c) 2025 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Emilio J. Gallego Arias
-/

import Lean
import ImpLab.Lang.Ast

open Lean
open Lean.Elab
open Lean.Elab.Term

namespace ImpLab

declare_syntax_cat imp_rhs
declare_syntax_cat imp_stmt
declare_syntax_cat imp_func

syntax num : imp_rhs
syntax "-" num : imp_rhs
syntax "add" ident ident : imp_rhs
syntax "sub" ident ident : imp_rhs
syntax "mul" ident ident : imp_rhs
syntax "div" ident ident : imp_rhs
syntax "call" ident "(" ident,* ")" : imp_rhs

syntax "let " ident " := " imp_rhs : imp_stmt
syntax "return " ident : imp_stmt

syntax "def " ident "(" ident,* ")" " := " "{" imp_stmt,* "}" : imp_func

/--
Program literal syntax for the toy language.
`imp%[...]` must contain only function definitions and include `main()` as entrypoint.
-/
syntax (name := impProgramTerm) "imp%[" imp_func,* "]" : term

/--
Convenience command macro to define a program declaration from DSL syntax.
The declaration type is inferred from the right-hand side (`ProgramInfo` for `imp%[...]`).
-/
syntax (name := impProgramDefCmd) "imp_program " ident " := " term : command

macro_rules
  | `(imp_program $name:ident := $program:term) =>
      `(def $name := $program)

private structure ProgramSyntaxInfo where
  located : Array LocatedStmt
  deriving TypeName

/-- Convert the custom infotree payload generated by `imp%[...]`. -/
def getProgramSyntaxInfo? : Elab.Info → Option (Array LocatedStmt)
  | .ofCustomInfo custom =>
    (custom.value.get? ProgramSyntaxInfo).map (·.located)
  | _ =>
    none

private def varOfIdent (id : TSyntax `ident) : Var :=
  id.getId.toString

private def parseNatLiteral (numStx : TSyntax `num) : TermElabM Nat :=
  match numStx.raw.isNatLit? with
  | some value =>
    pure value
  | none =>
    throwErrorAt numStx "expected a natural number literal"

private def parseRhs : Syntax → TermElabM Rhs
  | `(imp_rhs| $n:num) => do
    pure (.const (Int.ofNat (← parseNatLiteral n)))
  | `(imp_rhs| - $n:num) => do
    pure (.const (-(Int.ofNat (← parseNatLiteral n))))
  | `(imp_rhs| add $lhs:ident $rhs:ident) =>
    pure (.bin .add (varOfIdent lhs) (varOfIdent rhs))
  | `(imp_rhs| sub $lhs:ident $rhs:ident) =>
    pure (.bin .sub (varOfIdent lhs) (varOfIdent rhs))
  | `(imp_rhs| mul $lhs:ident $rhs:ident) =>
    pure (.bin .mul (varOfIdent lhs) (varOfIdent rhs))
  | `(imp_rhs| div $lhs:ident $rhs:ident) =>
    pure (.bin .div (varOfIdent lhs) (varOfIdent rhs))
  | `(imp_rhs| call $fn:ident($args:ident,*)) =>
    pure (.call (varOfIdent fn) (args.getElems.map varOfIdent))
  | stx =>
    throwErrorAt stx "invalid right-hand side"

private def parseStmt : Syntax → TermElabM Stmt
  | `(imp_stmt| let $dest:ident := $rhs:imp_rhs) => do
    pure (.assign (varOfIdent dest) (← parseRhs rhs))
  | `(imp_stmt| return $value:ident) =>
    pure (.return_ (varOfIdent value))
  | stx =>
    throwErrorAt stx
      "invalid toy-language statement; expected `let v := rhs` or `return v`"

private def spanOfSyntax (fileMap : FileMap) (stx : Syntax) : StmtSpan :=
  match stx.getPos?, stx.getTailPos? with
  | some startPos, some endPos =>
    let start := fileMap.toPosition startPos
    let ending := fileMap.toPosition endPos
    {
      startLine := start.line
      startColumn := start.column
      endLine := ending.line
      endColumn := ending.column
    }
  | _, _ =>
    default

private def pushProgramInfoNode (stx : Syntax) (located : Array LocatedStmt) : TermElabM Unit := do
  pushInfoLeaf <| .ofCustomInfo
    { stx
      value := Dynamic.mk ({ located } : ProgramSyntaxInfo) }

private structure ParsedFunc where
  fn : FuncDef
  located : Array LocatedStmt

private def parseFunc : FileMap → Syntax → TermElabM ParsedFunc
  | fileMap, `(imp_func| def $name:ident($params:ident,*) := { $body:imp_stmt,* }) => do
    let bodyStx := body.getElems
    let bodyStmt ← bodyStx.mapM parseStmt
    let mut located : Array LocatedStmt := #[]
    for h : i in [:bodyStx.size] do
      let stmtStx := bodyStx[i]
      let stmt := bodyStmt[i]!
      located := located.push
        { func := varOfIdent name
          stmtLine := i + 1
          stmt
          span := spanOfSyntax fileMap stmtStx }
    pure
      { fn :=
          { name := varOfIdent name
            params := params.getElems.map varOfIdent
            body := bodyStmt }
        located }
  | _, stx =>
    throwErrorAt stx "invalid function definition"

private def validateFunctionSet (funcs : Array FuncDef) : TermElabM Unit := do
  if !funcs.any (fun fn => fn.name = Program.mainName) then
    throwError "Invalid DSL program: missing required entry function `main`."
  match funcs.find? (fun fn => fn.name = Program.mainName) with
  | some mainFn =>
    if !mainFn.params.isEmpty then
      throwError "Invalid DSL program: `main` must have zero parameters."
  | none =>
    pure ()
  let hasDup :=
    (funcs.foldl (init := ((#[] : Array FuncName), false)) fun (seen, dup) fn =>
      if dup then
        (seen, true)
      else if seen.contains fn.name then
        (seen, true)
      else
        (seen.push fn.name, false)).2
  if hasDup then
    throwError "Invalid DSL program: duplicate function names are not allowed."

@[term_elab impProgramTerm]
def elabImpProgram : TermElab := fun stx _expectedType? => withRef stx do
  let fileMap ← getFileMap
  let funcStx := stx[1].getSepArgs
  let parsed ← funcStx.mapM (parseFunc fileMap)
  let functions := parsed.map (·.fn)
  validateFunctionSet functions
  let located := parsed.foldl (init := #[]) fun acc p => acc ++ p.located
  let program : Program := { functions }
  let programInfo : ProgramInfo := { program, located }
  let _ ←
    match programInfo.validate with
    | .ok info => pure info
    | .error err => throwError err
  pushProgramInfoNode stx located
  let expr := toExpr programInfo
  addTermInfo' stx expr (isDisplayableTerm := true)
  pure expr

end ImpLab
